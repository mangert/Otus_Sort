# Отчет по алгоритмам сортировки: Quick Sort и Merge Sort, внешние сортировки

## Часть 1: Реализация алгоритмов

### Быстрая сортировка (Quick Sort)
**QUICK1.** Реализация алгоритма **QuickSort** [`static void quick_sort(T* data, size_t size)`](../headers/Sorter.h) — базовая версия с выбором последнего элемента как pivot.<br>
**QUICK2.** Модифицированная реализация алгоритма **QuickSort** [`static void quick_sort_opt(T* data, size_t size)`](../headers/Sorter.h) — оптимизированная версия с выбором медианы трёх.<br>
**QUICK3.** Модифицированная реализация алгоритма **QuickSort** с защитой от переполнения стека [`static void quick_sort_safe(T* data, size_t size)`](../headers/Sorter.h) — защищённая версия с fallback на HeapSort при глубокой рекурсии.<br>

### Сортировка слиянием (Merge Sort)
**MERGE1.** Реализация алгоритма **MergeSort** [`static void merge_sort(T* data, size_t size)`](../headers/Sorter.h) — рекурсивная версия с единым временным буфером.<br>

#### Все пункты выполнены

## Часть 1.a: Таблица времени сортировки случайного массива

### Сравнительная таблица производительности на случайных данных (0.random)

| Алгоритм | 10² | 10³ | 10⁴ | 10⁵ | 10⁶ | 10⁷ |
|----------|-----|-----|-----|-----|-----|-----|
| **quick_sort** | 0 мс | 0 мс | 1 мс | 19 мс | 237 мс | 2.78 сек |
| **quick_sort_opt** | 0 мс | 0 мс | 2 мс | 19 мс | 236 мс | 2.75 сек |
| **quick_sort_safe** | 0 мс | 0 мс | 1 мс | 19 мс | 238 мс | 2.94 сек |
| **merge_sort** | 0 мс | 0 мс | 2 мс | 27 мс | 312 мс | 3.47 сек |
| *heap_sort* | 0 мс | 0 мс | 2 мс | 36 мс | 461 мс | 6.99 сек |
| *shell_sedgewick* | 0 мс | 0 мс | 2 мс | 27 мс | 324 мс | 3.81 сек |

**Примечания:**
- Все алгоритмы на 10², 10³ элементах показывают время <1 мс
- Quick Sort показывает наилучшие результаты на случайных данных
- Merge Sort демонстрирует стабильную производительность
- "-" в предыдущих таблицах означает пропуск теста из-за временных ограничений (>2 минут)

## Часть 2: Внешняя сортировка
# Отчет по реализации алгоритмов внешней сортировки

Функции реализованы в классе [`ExternalSorter.cpp`](../src/ExternalSorter.cpp)<br>
Примечание **класс** нешаблонный, работает только с `uint32_t` (входные данные — числа на отдельных строках)
шаблонизация потребовала бы написания сложного универсального парсера, что выходит за рамки ДЗ
### Выполнение пунктов задания:

**-** Функция (N, T) для генерации текстового файла из N строчек, на каждой строке записано случайное число от 1 до T - [`static void generate_file(const std::string& filename, size_t n, uint32_t lim))`](../src/ExternalSorter.cpp) <br>

**ES1** Реализация алгоритма внешней сортировки ExternalSort первым способом [`static void external_sort_method1(const std::string& input_file, const std::string& output_file, const std::string& temp_dir = "temp_merge")`](../src/ExternalSorter.cpp) <br>
**ES2** Реализация алгоритма внешней сортировки ExternalSort вторым способом, с двумя вспомогательными файлами [`static void external_sort_method2(const std::string& input_file, const std::string& output_file, const std::string& temp_dir = "temp_merge")`](../src/ExternalSorter.cpp) <br>
**ES3** Реализовать алгоритм внешней сортировки ExternalSort третьим способом, при первом проходе в память загружать блоки по 100 чисел, сортировать их любым другим алгоритмом и отправлять на выход, а потом действовать по алгоритму ES2  - [`static void external_sort_method3`][`static void external_sort_method2(const std::string& input_file, const std::string& output_file, const size_t block_size, std::function<void(uint32_t*, size_t)> sort_func, const std::string& temp_dir = "temp_block")`](../src/ExternalSorter.cpp) <br>
<br>
**-** Занести в сравнительную таблицу время сортировки файлов при: <br>
N = 10^2, 10^3, 10^4, 10^5, 10^6,
T = 10, N. (всего 10 вариантов сочетания N и T)<br> 
Для реализации этого пункта использовался отдельный класс тестирования [`ExternalTest`](../src/ExternalTest.cpp) <br>
Консольный вывод из тестов - [`output_part3_1.txt`](output_part3_1.txt).
Результаты и выводы в следующем параграфе.

## Условия выполнения
- **Аппаратное обеспечение**: Тестирование проводилось на HDD (SSD системный, но места недостаточно)

## Пропущенные тесты
- **ES1 для N=10^6, T=10^6**: Пропущен в связи с экстремально большим временем выполнения (создание 1 миллиона файлов заняло более 2 часов на этапе генерации)

## Сравнительная таблица времени выполнения (мс)

### ES1 — Bucket Sort (создание T файлов с последующим слиянием)

| N (кол-во чисел) | T = 10 | T = N |
|-----------------|--------|-------|
| 10² (100)       | 84     | 117   |
| 10³ (1,000)     | 54     | 2,365 |
| 10⁴ (10,000)    | 58     | 22,996 |
| 10⁵ (100,000)   | 460    | 279,219 |
| 10⁶ (1,000,000) | 12,192 | Пропущен |

### ES2 — Balanced Two-Way Merge Sort

| N (кол-во чисел) | T = 10 | T = N |
|-----------------|--------|-------|
| 10² (100)       | 104    | 105   |
| 10³ (1,000)     | 158    | 162   |
| 10⁴ (10,000)    | 379    | 348   |
| 10⁵ (100,000)   | 1,240  | 1,472 |
| 10⁶ (1,000,000) | 10,205 | 12,360 |

### ES3 — Block Sort (блоки по 100, внутренняя Shell Sort)

| N (кол-во чисел) | T = 10 | T = N |
|-----------------|--------|-------|
| 10² (100)       | 24     | 25    |
| 10³ (1,000)     | 84     | 77    |
| 10⁴ (10,000)    | 172    | 284   |
| 10⁵ (100,000)   | 826    | 908   |
| 10⁶ (1,000,000) | 7,654  | 9,440 |

### ES3 — Block Sort (блоки по 200, внутренняя Shell Sort)

| N (кол-во чисел) | T = 10 | T = N |
|-----------------|--------|-------|
| 10² (100)       | 22     | 24    |
| 10³ (1,000)     | 62     | 71    |
| 10⁴ (10,000)    | 140    | 156   |
| 10⁵ (100,000)   | 813    | 860   |
| 10⁶ (1,000,000) | 7,082  | 8,532 |

## Анализ и выводы

### 1. Сравнение алгоритмов при фиксированном размере блока (100)

**При N = 1,000,000, T = 10:**
- **ES1**: 12,192 мс
- **ES2**: 10,205 мс
- **ES3**: 7,654 мс

**ES3 показал наилучшую производительность**, опережая ES2 на ~25% и ES1 на ~37%.

### 2. Влияние параметра T

**Интересное наблюдение**: Хотя в ES2 и ES3 параметр T не используется непосредственно в алгоритме, характер данных при больших T меняется:
- **ES2**: При T = N выполняется в среднем на 10-20% медленнее, чем при T = 10
- **ES3 (блок 100)**: При T = N выполняется на 20-25% медленнее
- **ES3 (блок 200)**: При T = N выполняется на 15-20% медленнее

**Вывод**: Даже при отсутствии T в алгоритме, более равномерное распределение случайных чисел (большой T) приводит к ухудшению производительности на 10-25%.

### 3. Оптимальный размер блока для ES3

**Сравнение блоков 100 и 200 при N = 1,000,000, T = 10:**
- **Блок 100**: 7,654 мс
- **Блок 200**: 7,082 мс (на ~7.5% быстрее)

**Блок 200 показывает лучшую производительность** для больших N, так как:
- Уменьшается количество слияний на начальном этапе
- Увеличивается эффективность внутренней сортировки (Shell Sort)

### 4. Масштабируемость алгоритмов

**Отношение времени при N=10⁶ к N=10⁵:**

| Алгоритм | T = 10 | T = N |
|----------|--------|-------|
| ES1      | ~26.5x | —     |
| ES2      | ~8.2x  | ~8.4x |
| ES3 (100)| ~9.3x  | ~10.4x|
| ES3 (200)| ~8.7x  | ~9.9x |

**ES2 показывает лучшую масштабируемость** с ростом N.

### 5. Анализ ES1 (Bucket Sort)

**Преимущества:**
- При малых T (10) показывает хорошие результаты для малых N

**Недостатки:**
- Катастрофическая деградация при T = N (экспоненциальный рост)
- Непрактичен для больших T из-за создания огромного количества файлов
- При N=100,000, T=100,000 время выполнения достигает почти 5 минут

### 6. Рекомендации по выбору алгоритма

1. **Для малых T (≤100) и любых N**: ES3 с блоком 200
2. **Для больших T (близких к N)**: ES2 (наиболее стабилен)
3. **Для очень больших T (T ≈ N)**: ES1 не рекомендуется использовать
4. **Оптимальный размер блока для ES3**: 200 элементов (баланс между эффективностью внутренней сортировки и количеством слияний)

## Ограничения и возможные улучшения

1. **Аппаратное**: Тестирование на HDD вместо SSD увеличивает время I/O операций
2. **Алгоритмическое**: ES1 можно оптимизировать, создавая не физические файлы, а буферы в памяти при малых размерах блоков
3. **Параметризация**: Размер блока в ES3 можно подбирать динамически в зависимости от доступной памяти

## Выводы по алгоритмам внешней сортировки

Реализованы три алгоритма внешней сортировки с различными подходами. **ES3 с блокировкой и предварительной внутренней сортировкой показал наилучшую производительность** в большинстве тестов, особенно при оптимальном размере блока (200 элементов). **ES2 демонстрирует лучшую масштабируемость** и стабильность при изменении параметра T. **ES1 эффективен только при очень малых T**, но становится непрактичным при T близких к N.

Параметр T влияет на производительность даже в алгоритмах, где он не используется явно, из-за изменения характера распределения данных. Оптимальный размер блока для ES3 зависит от размера данных и должен подбираться экспериментально для конкретной аппаратной конфигурации.

## Часть 3: Комплексный анализ алгоритмов внутренней сортировки

**Шаблонный класс для тестов**: [`class Test`](../headers/Test.h), консольный вывод результатов тестирования [`output_part3.txt`](output_part3.txt)<br>
Для прогона всех алгоритмов через приложенный комплекс тестов сформированы параметры запуска тестов - [`test_cases.cpp`](../src/test_cases.cpp).<br>
**Примечание:** класс тестирования взят из прошлого домашнего задания, параметры запуска тестов отредактированы — добавлены алгоритмы QuickSort и MergeSort.

Запись чисел отсортированного массива в файл результата:<br>
Функция запуска тестов шаблонного класса тестирования принимает опциональный параметр, определяющий, следует ли записывать отсортированный массив в файл. Для экономии времени и места полная программа тестирования проводилась без записи отсортированного массива в файлы (проверка данных в памяти). Отдельно были запущены тесты с записью в файлы для проверки корректности работы.

### Сводная таблица производительности (100K элементов)

| Алгоритм | Random | Digits | Sorted | Revers | Адаптивность | Стабильность |
|----------|--------|--------|--------|--------|--------------|--------------|
| **quick_sort** | 19 мс | *пропуск* | 87 мс | *пропуск* | Низкая | Нет |
| **quick_sort_opt** | 19 мс | *пропуск* | 22 мс | 17 мс | Средняя | Нет |
| **quick_sort_safe** | 19 мс | 36 мс | 26 мс | 17 мс | Высокая | Нет |
| **merge_sort** | 27 мс | 22 мс | 19 мс | 21 мс | Низкая | **Да** |
| *heap_sort* | 36 мс | 28 мс | 29 мс | 27 мс | Низкая | Нет |

### Сводная таблица производительности (1M элементов)

| Алгоритм | Random | Digits | Sorted | Revers |
|----------|--------|--------|--------|--------|
| **quick_sort** | 237 мс | *пропуск* | 1.26 сек | *пропуск* |
| **quick_sort_opt** | 236 мс | *пропуск* | 268 мс | 213 мс |
| **quick_sort_safe** | 238 мс | 431 мс | 332 мс | 216 мс |
| **merge_sort** | 312 мс | 240 мс | 207 мс | 208 мс |
| *heap_sort* | 461 мс | 313 мс | 345 мс | 323 мс |

### Сводная таблица производительности (10M элементов)

| Алгоритм | Random | Digits | Sorted | Revers |
|----------|--------|--------|--------|--------|
| **quick_sort** | 2.78 сек | *пропуск* | 16.66 сек | *пропуск* |
| **quick_sort_opt** | 2.75 сек | *пропуск* | 2.69 сек | 2.52 сек |
| **quick_sort_safe** | 2.94 сек | 5.26 сек | 3.22 сек | 2.62 сек |
| **merge_sort** | 3.47 сек | 2.56 сек | 2.30 сек | 2.45 сек |
| *heap_sort* | 6.99 сек | 3.66 сек | 3.96 сек | 3.73 сек |

## Детальный анализ Quick Sort

### Особенности реализаций:

1. **quick_sort (базовая)**:
   - Выбор последнего элемента как pivot
   - Деградирует до O(n²) на отсортированных данных
   - Не работает на больших digits/revers массивах

2. **quick_sort_opt (с медианой трёх)**:
   - Защита от худшего случая на отсортированных данных
   - Улучшенная производительность на sorted/revers
   - Всё ещё проблемы с digits данными

3. **quick_sort_safe (с защитой)**:
   - Fallback на HeapSort при глубокой рекурсии
   - Работает на всех типах данных
   - Немного медленнее из-за дополнительных проверок

### Преимущества Quick Sort:
1. **Высокая скорость** на случайных данных (2.75 сек на 10⁷)
2. **In-place алгоритм** — не требует дополнительной памяти
3. **Кэш-эффективность** — хорошая локальность данных

### Недостатки Quick Sort:
1. **Нестабильный** (не сохраняет порядок равных элементов)
2. **Чувствительность к выбору pivot**
3. **Рекурсивный** (риск stack overflow без защиты)
4. **Проблемы с повторяющимися элементами** (digits тесты)

## Детальный анализ Merge Sort

### Характеристики Merge Sort:
1. **Гарантированная сложность O(n log n)** во всех случаях
2. **Стабильная сортировка** — сохраняет порядок равных элементов
3. **Требует дополнительной памяти O(n)** для временного буфера
4. **Хорошая производительность** на всех типах данных

### Производительность по типам данных:
- **Digits (uint8_t)**: 2.56 сек на 10M — **очень хорошо**
- **Sorted**: 2.30 сек на 10M — **лучший результат**
- **Random**: 3.47 сек на 10M — стабильно
- **Revers**: 2.45 сек на 10M — равномерно

### Особенности реализации:
- Единый временный буфер для всего алгоритма
- Рекурсивное деление массива
- Стабильное слияние с использованием `<=` сравнения

## Сравнительный анализ алгоритмов

### По производительности на случайных данных (10⁷ элементов):

| Место | Алгоритм | Время | Относительно лучшего |
|-------|----------|-------|---------------------|
| 1 | **quick_sort_opt** | 2.75 сек | 100% |
| 2 | **quick_sort** | 2.78 сек | +1% |
| 3 | **quick_sort_safe** | 2.94 сек | +7% |
| 4 | **merge_sort** | 3.47 сек | +26% |
| 5 | *shell_sedgewick* | 3.81 сек | +39% |
| 6 | *heap_sort* | 6.99 сек | +154% |

### По адаптивности (разница Random vs Sorted на 10⁷):

| Алгоритм | Random | Sorted | Отношение | Адаптивность |
|----------|--------|--------|-----------|--------------|
| **quick_sort** | 2.78 сек | 16.66 сек | ×6.0 | Очень низкая |
| **quick_sort_opt** | 2.75 сек | 2.69 сек | ×0.98 | Высокая |
| **merge_sort** | 3.47 сек | 2.30 сек | ×0.66 | Высокая |
| *heap_sort* | 6.99 сек | 3.96 сек | ×0.57 | Средняя |

### По стабильности и памяти:

| Алгоритм | Стабильность | Память | In-place |
|----------|--------------|--------|----------|
| **merge_sort** | **Да** | O(n) | Нет |
| **quick_sort*** | Нет | O(log n) рекурсия | **Да** |
| **heap_sort** | Нет | O(1) | **Да** |
| *shell_sedgewick* | Нет | O(1) | **Да** |

## Ключевые наблюдения

### 1. Влияние оптимизаций на Quick Sort:
- **Медиана трёх** решает проблему с отсортированными данными
- **Защита от рекурсии** позволяет работать на сложных данных (digits)
- **Базовый QuickSort** непригоден для production использования

### 2. Сравнение QuickSort и MergeSort:
- **QuickSort быстрее** на случайных данных (2.75 сек vs 3.47 сек)
- **MergeSort стабильнее** по производительности на разных типах данных
- **MergeSort стабильный алгоритм**, QuickSort — нет
- **MergeSort требует O(n) памяти**, QuickSort — in-place

### 3. Производительность на digits данных:
- **MergeSort показывает лучшие результаты** (2.56 сек)
- QuickSort страдает от множества одинаковых элементов
- **HeapSort также хорошо справляется** (3.66 сек)

### 4. Рекурсия vs Итерация:
- QuickSort с защитой (рекурсия + fallback) показал хорошие результаты
- MergeSort рекурсивный, но глубина log₂(n) безопасна
- Итеративные версии могут быть полезны для очень больших данных

## Практические рекомендации

### Когда использовать QuickSort:
1. **Общий случай случайных данных** — максимальная производительность
2. **Ограничения по памяти** — in-place алгоритм
3. **Когда стабильность не важна**

**Рекомендуемая версия:** `quick_sort_opt` (с медианой трёх)

### Когда использовать MergeSort:
1. **Требуется стабильность** — сохранение порядка равных элементов
2. **Данные с повторениями** (например, digits)
3. **Гарантированное время выполнения** — нет деградации до O(n²)
4. **Когда есть достаточно памяти** для временного буфера

### Когда использовать HeapSort:
1. **Жёсткие ограничения по памяти** — строго in-place
2. **Требуется гарантированное O(n log n)** без дополнительной памяти
3. **Реализация приоритетных очередей**

## Выводы

### 1. Подтверждение теоретических ожиданий:
- **QuickSort действительно самый быстрый** на случайных данных (в среднем случае)
- **MergeSort обеспечивает стабильность** ценой дополнительной памяти
- **Оптимизации QuickSort критически важны** для практического использования
- **O(n log n) алгоритмы превосходят** квадратичные на больших данных

### 2. Неожиданные результаты:
- **MergeSort оказался быстрее QuickSort** на digits данных
- **Базовый QuickSort деградирует драматически** на отсортированных данных
- **QuickSort с медианой трёх решает проблему** sorted/revers, но не digits
- **MergeSort показывает лучшую адаптивность** к разным типам данных

### 3. Рекомендации по выбору алгоритма:

**Для общего использования:**
- **quick_sort_opt** — лучший баланс скорости и надёжности
- **merge_sort** — если нужна стабильность или данные с повторениями

**Специальные случаи:**
- **Очень большие массивы (>10⁷)** — merge_sort (предсказуемая память)
- **Встроенные системы с ограниченной памятью** — heap_sort
- **Данные с множеством повторений** — merge_sort или counting sort
- **Почти отсортированные данные** — insertion_sort или merge_sort

## Заключение

Быстрая сортировка подтвердила свою репутацию самого быстрого алгоритма общего назначения, но только в оптимизированной версии с защитой от худших случаев. Сортировка слиянием показала отличную стабильность и предсказуемость производительности на всех типах данных.

**Для большинства практических задач рекомендуется `quick_sort_opt`** как оптимальный баланс производительности и надёжности. **`merge_sort`** следует выбирать, когда критически важны стабильность или работа с данными, содержащими много повторений.

Оба алгоритма демонстрируют превосходство O(n log n) алгоритмов над квадратичными на больших объёмах данных, что полностью соответствует теоретическим ожиданиям.