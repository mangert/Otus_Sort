# Отчет о выполнении домашнего задания

### Часть 1 

BUB1. Реализация алгоритма **BubbleSort** [`static void bubble_sort(T* data, size_t size)`](../headers/Sorter.h).<br>
INS1. Реализация алгоритма **InsertionSort** [`static void insertion_sort(T* data, size_t size)`](../headers/Sorter.h).<br>
SHS1. Реализация алгоритма **ShellSort** [`static void shell_sort(T* data, size_t size)`](../headers/Sorter.h).<br>

Сравнительные таблицы времени сортировки случайных массивов для каждого алгоритма представлены в третьей части отчета.

#### Все пункты выполнены

### Часть 2

BUB2. Оптимизированная реализация алгоритма **BubbleSort** [`static void bubble_sort_opt(T* data, size_t size)`](../headers/Sorter.h).<br>
INS2. Оптимизированная реализация алгоритма **InsertionSort** (сдвиг вместо обмена) [`static void insertion_sort_shift(T* data, size_t size)`](../headers/Sorter.h).<br>
INS3. Оптимизированая реализация алгоритма **InsertionSort** (бинарный поиск места вставки) [`static void insertion_sort_bin(T* data, size_t size)`](../headers/Sorter.h).<br>
SHS2, SHS3. Оптимизированые алгоритмы **ShellSort** - сделаны реализации с последовательностью Кнута, Хиббарда и Седжвика:<br>
	***Кнут:*** [`static void shell_sort_knuth_func(T* data, size_t size)`](../headers/Sorter.h).<br>
	***Кнут:*** [`static void shell_sort_knuth_arr(T* data, size_t size)`](../headers/Sorter.h) - модификация с предрассчитанными интервалами.<br>
	***Хиббард:*** [`static void shell_sort_hibbard_func(T* data, size_t size)`](../headers/Sorter.h).<br>
	***Хиббард:*** [`static void shell_sort_hibbard_arr(T* data, size_t size)`](../headers/Sorter.h)- модификация с предрассчитанными интервалами.<br>
	***Седжвик:*** [`static void shell_sort_sedgewick(T* data, size_t size)`](../headers/Sorter.h) с предрассчитанными интервалами.<br>

Сравнительные таблицы времени сортировки случайных массивов для каждого алгоритма представлены в третьей части отчета.	

#### Все пункты выполнены

### Часть 3

**Шаблонный класс для тестов**: [`class Test`](../headers/Test.h), консольный вывод результатов тестирования [`output.txt`](output.txt)<br>
Для прогона всех алгоритмов через приложенный комплекс тестов сформированы параметры запуска тестов - [`test_cases.cpp`](../src/test_cases.cpp).<br>

Запись чисел отсортированного массива в файл результата:<br>
Функция запуска тестов шаблонного класса тестирования принимает опциональный параметр, определяющий, следует ли записывать отсортированный массив в файл. Для экономии времени и места полная программа тестирования проводилась без записи отсортированного массива в файлы (проверка данных в памяти). 
Отдельно были запущены тесты сортировки с последовательностью Седжвика с записью в файлы, один из результирующих файлов представлен как образец [`test.5.sorted`](test.5.sorted)
В консольном выводе [`output.txt`](output.txt) этот блок вывода находится после вывода комплексного тестирования.


### Анализ результатов тестирования алгоритмов сортировки

## Краткое резюме

| Категория | Алгоритмы | Макс. размер | Время (10^5) | Время (10^6) | Время (10^7) |
|-----------|-----------|--------------|--------------|--------------|--------------|
| **Медленные** | Bubble, Selection | 100K | ~50 сек | - | - |
| **Средние** | Insertion (обычный) | 500K | ~20 сек | - | - |
| **Быстрые** | Insertion (бинарный) | 1M | ~16 мин | - | - |
| **Очень быстрые** | Все Shell сортировки | без лимита | 7-35 мс | 85-500 мс | 1-7 сек |

## Сравнительная таблица производительности (100K элементов)

| Алгоритм | Random | Digits | Sorted | Revers | Адаптивность |
|----------|--------|--------|--------|--------|--------------|
| **bubble** | 50.6 сек | 49.8 сек | 15.0 сек | 46.5 сек | Низкая |
| **bubble_opt** | 51.4 сек | 48.1 сек | 14.5 сек | 43.9 сек | Средняя |
| **insertion** | 22.4 сек | 19.3 сек | 0.6 сек | 45.2 сек | Высокая |
| **insertion_shift** | 10.5 сек | 8.0 сек | 0.3 сек | 21.5 сек | Высокая |
| **insertion_bin** | 9.5 сек | 7.6 сек | 0.3 сек | 18.7 сек | Высокая |
| **selection** | 13.4 сек | 13.7 сек | 13.4 сек | 13.6 сек | Низкая |
| **shell** | 34 мс | 14 мс | 22 мс | 11 мс | Высокая |
| **shell_knuth_arr** | 29 мс | 10 мс | 19 мс | 7 мс | Высокая |
| **shell_sedgewick** | 27 мс | 10 мс | 18 мс | 7 мс | Высокая |

*Примечание: Маленькие тесты (1, 10, 100, 1000 элементов) у всех алгоритмов показывают 0-4 мс, поэтому в таблицу не включены.*

## Сравнительная таблица производительности (1M элементов)

| Алгоритм | Random | Digits | Sorted | Revers |
|----------|--------|--------|--------|--------|
| **insertion_bin** | 15.5 мин | 12.8 мин | 24.5 сек | 31.0 мин |
| **shell** | 465 мс | 157 мс | 310 мс | 130 мс |
| **shell_knuth_arr** | 428 мс | 119 мс | 273 мс | 85 мс |
| **shell_knuth_func** | 456 мс | 113 мс | 280 мс | 85 мс |
| **shell_hibbard_arr** | 486 мс | 139 мс | 327 мс | 118 мс |
| **shell_hibbard_func** | 493 мс | 142 мс | 338 мс | 132 мс |
| **shell_sedgewick** | 344 мс | 128 мс | 249 мс | 94 мс |

*Примечание: Bubble, Selection и обычные Insertion сортировки не тестировались на 1M из-за временных ограничений.*

## Сравнительная таблица производительности (10M элементов)

| Алгоритм | Random | Digits | Sorted | Revers |
|----------|--------|--------|--------|--------|
| **shell** | 6.97 сек | 1.85 сек | 4.45 сек | 1.55 сек |
| **shell_knuth_arr** | 6.32 сек | 1.28 сек | 3.82 сек | 1.09 сек |
| **shell_knuth_func** | 6.48 сек | 1.31 сек | 3.97 сек | 1.04 сек |
| **shell_hibbard_arr** | 7.17 сек | 1.55 сек | 4.69 сек | 1.37 сек |
| **shell_hibbard_func** | 7.35 сек | 1.61 сек | 4.81 сек | 1.42 сек |
| **shell_sedgewick** | 4.51 сек | 1.37 сек | 2.98 сек | 1.10 сек |

## Рейтинг алгоритмов по производительности (10M элементов, случайные данные)

| Место | Алгоритм | Время | Относительно лучшего |
|-------|----------|-------|---------------------|
| 1 | **shell_sedgewick** | 4.51 сек | 100% |
| 2 | **shell_knuth_arr** | 6.32 сек | +40% |
| 3 | **shell_knuth_func** | 6.48 сек | +44% |
| 4 | **shell** | 6.97 сек | +55% |
| 5 | **shell_hibbard_arr** | 7.17 сек | +59% |
| 6 | **shell_hibbard_func** | 7.35 сек | +63% |

## Анализ влияния типа данных на производительность

### Наиболее чувствительные алгоритмы:
1. **Insertion сортировки**:
   - Sorted: в 50-100 раз быстрее, чем Random
   - Revers: в 2 раза медленнее Random
   - *Вывод:* Чрезвычайно адаптивны к уже отсортированным данным

2. **Bubble сортировки**:
   - Sorted: в 3-3.5 раза быстрее, чем Random
   - Revers: примерно как Random
   - *Вывод:* Умеренно адаптивны

3. **Selection сортировка**:
   - Все типы данных: одинаковое время
   - *Вывод:* Не адаптивна вообще

4. **Shell сортировки**:
   - Revers/Digits: часто быстрее, чем Random
   - Sorted: иногда медленнее, чем Random
   - *Вывод:* По-разному реагируют на структуру данных

## Ключевые выводы

### 1. О производительности
- **Алгоритмы Shell** демонстрируют превосходную производительность на больших объемах данных
- **Bubble и Selection сортировки** практически непригодны для массивов > 100K элементов
- **Insertion с бинарным поиском** - единственный из "простых" алгоритмов, способный обработать 1M элементов

### 2. Об адаптивности
- **Insertion сортировки** - самые адаптивные: на отсортированных данных работают в десятки раз быстрее
- **Bubble оптимизированная** немного адаптивнее обычной Bubble
- **Selection сортировка** абсолютно не адаптивна
- **Алгоритмы Shell** показывают разную степень адаптивности в зависимости от последовательности

### 3. О пропущенных тестах
Медленные алгоритмы были пропущены на больших объемах данных по следующим причинам:

| Алгоритм | Макс. тестируемый размер | Причина пропуска больших тестов |
|----------|--------------------------|--------------------------------|
| Bubble | 100K | Время выполнения ~50 сек уже на 100K, на 1M потребовалось бы ~83 минуты |
| Selection | 100K | Аналогично Bubble, O(n²) сложность |
| Insertion (обычный) | 100K | На 1M элементов время ~30-40 минут |
| Insertion_bin | 1M | На 10M потребовалось бы ~2.5-3 часа |

### 4. Рекомендации по выбору алгоритма

**Для малых массивов (< 1K):**
- Любой алгоритм подходит
- Insertion сортировка может быть оптимальной из-за простоты реализации

**Для средних массивов (1K-100K):**
- Insertion с бинарным поиском или сдвигом
- Простые алгоритмы Shell

**Для больших массивов (> 100K):**
- **shell_sedgewick** - лучший выбор
- **shell_knuth_arr** - хорошая альтернатива

**Специальные случаи:**
- Если данные почти отсортированы: **insertion_shift**
- Если нужна стабильность: **insertion_bin**
- Если важна простота: **shell** (базовая версия)

## Заключение

Тестирование подтвердило теоретические ожидания:
1. Квадратичные алгоритмы (O(n²)) непригодны для больших данных
2. Алгоритмы Shell (O(n log² n)) демонстрируют отличную производительность
3. Среди алгоритмов Shell, последовательность Седжвика показала наилучшие результаты
4. Адаптивность Insertion сортировок делает их хорошим выбором для частично отсортированных данных
5. Размер типа данных (uint8_t vs uint32_t) влияет на производительность, особенно для алгоритмов Shell

**Рекомендуемый алгоритм для общего использования: shell_sedgewick** - демонстрирует лучший баланс производительности, адаптивности и стабильности результатов на всех типах данных.