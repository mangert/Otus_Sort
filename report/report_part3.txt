# Отчёт по алгоритмам сортировки: Quick Sort и Merge Sort

## Часть 1: Реализация алгоритмов

### Быстрая сортировка (Quick Sort)
**QUICK1.** Реализация алгоритма **QuickSort** [`static void quick_sort(T* data, size_t size)`](../headers/Sorter.h) — базовая версия с выбором последнего элемента как pivot.<br>
**QUICK2.** Модифицированная реализация алгоритма **QuickSort** [`static void quick_sort_opt(T* data, size_t size)`](../headers/Sorter.h) — оптимизированная версия с выбором медианы трёх.<br>
**QUICK3.** Модифицированная реализация алгоритма **QuickSort** с защитой от переполнения стека [`static void quick_sort_safe(T* data, size_t size)`](../headers/Sorter.h) — защищённая версия с fallback на HeapSort при глубокой рекурсии.<br>

### Сортировка слиянием (Merge Sort)
**MERGE1.** Реализация алгоритма **MergeSort** [`static void merge_sort(T* data, size_t size)`](../headers/Sorter.h) — рекурсивная версия с единым временным буфером.<br>

#### Все пункты выполнены

## Часть 2: Таблица времени сортировки случайного массива

### Сравнительная таблица производительности на случайных данных (0.random)

| Алгоритм | 10² | 10³ | 10⁴ | 10⁵ | 10⁶ | 10⁷ |
|----------|-----|-----|-----|-----|-----|-----|
| **quick_sort** | 0 мс | 0 мс | 1 мс | 19 мс | 237 мс | 2.78 сек |
| **quick_sort_opt** | 0 мс | 0 мс | 2 мс | 19 мс | 236 мс | 2.75 сек |
| **quick_sort_safe** | 0 мс | 0 мс | 1 мс | 19 мс | 238 мс | 2.94 сек |
| **merge_sort** | 0 мс | 0 мс | 2 мс | 27 мс | 312 мс | 3.47 сек |
| *heap_sort* | 0 мс | 0 мс | 2 мс | 36 мс | 461 мс | 6.99 сек |
| *shell_sedgewick* | 0 мс | 0 мс | 2 мс | 27 мс | 324 мс | 3.81 сек |

**Примечания:**
- Все алгоритмы на 10², 10³ элементах показывают время <1 мс
- Quick Sort показывает наилучшие результаты на случайных данных
- Merge Sort демонстрирует стабильную производительность
- "-" в предыдущих таблицах означает пропуск теста из-за временных ограничений (>2 минут)

## Часть 3: Комплексный анализ алгоритмов

**Шаблонный класс для тестов**: [`class Test`](../headers/Test.h), консольный вывод результатов тестирования [`output_part3.txt`](output_part3.txt)<br>
Для прогона всех алгоритмов через приложенный комплекс тестов сформированы параметры запуска тестов - [`test_cases.cpp`](../src/test_cases.cpp).<br>
**Примечание:** класс тестирования взят из прошлого домашнего задания, параметры запуска тестов отредактированы — добавлены алгоритмы QuickSort и MergeSort.

Запись чисел отсортированного массива в файл результата:<br>
Функция запуска тестов шаблонного класса тестирования принимает опциональный параметр, определяющий, следует ли записывать отсортированный массив в файл. Для экономии времени и места полная программа тестирования проводилась без записи отсортированного массива в файлы (проверка данных в памяти). Отдельно были запущены тесты с записью в файлы для проверки корректности работы.

### Сводная таблица производительности (100K элементов)

| Алгоритм | Random | Digits | Sorted | Revers | Адаптивность | Стабильность |
|----------|--------|--------|--------|--------|--------------|--------------|
| **quick_sort** | 19 мс | *пропуск* | 87 мс | *пропуск* | Низкая | Нет |
| **quick_sort_opt** | 19 мс | *пропуск* | 22 мс | 17 мс | Средняя | Нет |
| **quick_sort_safe** | 19 мс | 36 мс | 26 мс | 17 мс | Высокая | Нет |
| **merge_sort** | 27 мс | 22 мс | 19 мс | 21 мс | Низкая | **Да** |
| *heap_sort* | 36 мс | 28 мс | 29 мс | 27 мс | Низкая | Нет |

### Сводная таблица производительности (1M элементов)

| Алгоритм | Random | Digits | Sorted | Revers |
|----------|--------|--------|--------|--------|
| **quick_sort** | 237 мс | *пропуск* | 1.26 сек | *пропуск* |
| **quick_sort_opt** | 236 мс | *пропуск* | 268 мс | 213 мс |
| **quick_sort_safe** | 238 мс | 431 мс | 332 мс | 216 мс |
| **merge_sort** | 312 мс | 240 мс | 207 мс | 208 мс |
| *heap_sort* | 461 мс | 313 мс | 345 мс | 323 мс |

### Сводная таблица производительности (10M элементов)

| Алгоритм | Random | Digits | Sorted | Revers |
|----------|--------|--------|--------|--------|
| **quick_sort** | 2.78 сек | *пропуск* | 16.66 сек | *пропуск* |
| **quick_sort_opt** | 2.75 сек | *пропуск* | 2.69 сек | 2.52 сек |
| **quick_sort_safe** | 2.94 сек | 5.26 сек | 3.22 сек | 2.62 сек |
| **merge_sort** | 3.47 сек | 2.56 сек | 2.30 сек | 2.45 сек |
| *heap_sort* | 6.99 сек | 3.66 сек | 3.96 сек | 3.73 сек |

## Детальный анализ Quick Sort

### Особенности реализаций:

1. **quick_sort (базовая)**:
   - Выбор последнего элемента как pivot
   - Деградирует до O(n²) на отсортированных данных
   - Не работает на больших digits/revers массивах

2. **quick_sort_opt (с медианой трёх)**:
   - Защита от худшего случая на отсортированных данных
   - Улучшенная производительность на sorted/revers
   - Всё ещё проблемы с digits данными

3. **quick_sort_safe (с защитой)**:
   - Fallback на HeapSort при глубокой рекурсии
   - Работает на всех типах данных
   - Немного медленнее из-за дополнительных проверок

### Преимущества Quick Sort:
1. **Высокая скорость** на случайных данных (2.75 сек на 10⁷)
2. **In-place алгоритм** — не требует дополнительной памяти
3. **Кэш-эффективность** — хорошая локальность данных

### Недостатки Quick Sort:
1. **Нестабильный** (не сохраняет порядок равных элементов)
2. **Чувствительность к выбору pivot**
3. **Рекурсивный** (риск stack overflow без защиты)
4. **Проблемы с повторяющимися элементами** (digits тесты)

## Детальный анализ Merge Sort

### Характеристики Merge Sort:
1. **Гарантированная сложность O(n log n)** во всех случаях
2. **Стабильная сортировка** — сохраняет порядок равных элементов
3. **Требует дополнительной памяти O(n)** для временного буфера
4. **Хорошая производительность** на всех типах данных

### Производительность по типам данных:
- **Digits (uint8_t)**: 2.56 сек на 10M — **очень хорошо**
- **Sorted**: 2.30 сек на 10M — **лучший результат**
- **Random**: 3.47 сек на 10M — стабильно
- **Revers**: 2.45 сек на 10M — равномерно

### Особенности реализации:
- Единый временный буфер для всего алгоритма
- Рекурсивное деление массива
- Стабильное слияние с использованием `<=` сравнения

## Сравнительный анализ алгоритмов

### По производительности на случайных данных (10⁷ элементов):

| Место | Алгоритм | Время | Относительно лучшего |
|-------|----------|-------|---------------------|
| 1 | **quick_sort_opt** | 2.75 сек | 100% |
| 2 | **quick_sort** | 2.78 сек | +1% |
| 3 | **quick_sort_safe** | 2.94 сек | +7% |
| 4 | **merge_sort** | 3.47 сек | +26% |
| 5 | *shell_sedgewick* | 3.81 сек | +39% |
| 6 | *heap_sort* | 6.99 сек | +154% |

### По адаптивности (разница Random vs Sorted на 10⁷):

| Алгоритм | Random | Sorted | Отношение | Адаптивность |
|----------|--------|--------|-----------|--------------|
| **quick_sort** | 2.78 сек | 16.66 сек | ×6.0 | Очень низкая |
| **quick_sort_opt** | 2.75 сек | 2.69 сек | ×0.98 | Высокая |
| **merge_sort** | 3.47 сек | 2.30 сек | ×0.66 | Высокая |
| *heap_sort* | 6.99 сек | 3.96 сек | ×0.57 | Средняя |

### По стабильности и памяти:

| Алгоритм | Стабильность | Память | In-place |
|----------|--------------|--------|----------|
| **merge_sort** | **Да** | O(n) | Нет |
| **quick_sort*** | Нет | O(log n) рекурсия | **Да** |
| **heap_sort** | Нет | O(1) | **Да** |
| *shell_sedgewick* | Нет | O(1) | **Да** |

## Ключевые наблюдения

### 1. Влияние оптимизаций на Quick Sort:
- **Медиана трёх** решает проблему с отсортированными данными
- **Защита от рекурсии** позволяет работать на сложных данных (digits)
- **Базовый QuickSort** непригоден для production использования

### 2. Сравнение QuickSort и MergeSort:
- **QuickSort быстрее** на случайных данных (2.75 сек vs 3.47 сек)
- **MergeSort стабильнее** по производительности на разных типах данных
- **MergeSort стабильный алгоритм**, QuickSort — нет
- **MergeSort требует O(n) памяти**, QuickSort — in-place

### 3. Производительность на digits данных:
- **MergeSort показывает лучшие результаты** (2.56 сек)
- QuickSort страдает от множества одинаковых элементов
- **HeapSort также хорошо справляется** (3.66 сек)

### 4. Рекурсия vs Итерация:
- QuickSort с защитой (рекурсия + fallback) показал хорошие результаты
- MergeSort рекурсивный, но глубина log₂(n) безопасна
- Итеративные версии могут быть полезны для очень больших данных

## Практические рекомендации

### Когда использовать QuickSort:
1. **Общий случай случайных данных** — максимальная производительность
2. **Ограничения по памяти** — in-place алгоритм
3. **Когда стабильность не важна**

**Рекомендуемая версия:** `quick_sort_opt` (с медианой трёх)

### Когда использовать MergeSort:
1. **Требуется стабильность** — сохранение порядка равных элементов
2. **Данные с повторениями** (например, digits)
3. **Гарантированное время выполнения** — нет деградации до O(n²)
4. **Когда есть достаточно памяти** для временного буфера

### Когда использовать HeapSort:
1. **Жёсткие ограничения по памяти** — строго in-place
2. **Требуется гарантированное O(n log n)** без дополнительной памяти
3. **Реализация приоритетных очередей**

## Выводы

### 1. Подтверждение теоретических ожиданий:
- **QuickSort действительно самый быстрый** на случайных данных (в среднем случае)
- **MergeSort обеспечивает стабильность** ценой дополнительной памяти
- **Оптимизации QuickSort критически важны** для практического использования
- **O(n log n) алгоритмы превосходят** квадратичные на больших данных

### 2. Неожиданные результаты:
- **MergeSort оказался быстрее QuickSort** на digits данных
- **Базовый QuickSort деградирует драматически** на отсортированных данных
- **QuickSort с медианой трёх решает проблему** sorted/revers, но не digits
- **MergeSort показывает лучшую адаптивность** к разным типам данных

### 3. Рекомендации по выбору алгоритма:

**Для общего использования:**
- **quick_sort_opt** — лучший баланс скорости и надёжности
- **merge_sort** — если нужна стабильность или данные с повторениями

**Специальные случаи:**
- **Очень большие массивы (>10⁷)** — merge_sort (предсказуемая память)
- **Встроенные системы с ограниченной памятью** — heap_sort
- **Данные с множеством повторений** — merge_sort или counting sort
- **Почти отсортированные данные** — insertion_sort или merge_sort

## Заключение

Быстрая сортировка подтвердила свою репутацию самого быстрого алгоритма общего назначения, но только в оптимизированной версии с защитой от худших случаев. Сортировка слиянием показала отличную стабильность и предсказуемость производительности на всех типах данных.

**Для большинства практических задач рекомендуется `quick_sort_opt`** как оптимальный баланс производительности и надёжности. **`merge_sort`** следует выбирать, когда критически важны стабильность или работа с данными, содержащими много повторений.

Оба алгоритма демонстрируют превосходство O(n log n) алгоритмов над квадратичными на больших объёмах данных, что полностью соответствует теоретическим ожиданиям.