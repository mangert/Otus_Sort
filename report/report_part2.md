# Отчет о выполнении домашнего задания

### Часть 1 

SEL1. Реализация алгоритма **SelectionSort** [`static void selection_sort(T* data, size_t size)`](../headers/Sorter.h).<br>
HIP1. Реализация алгоритма **HeapSort** [`static void heap_sort(T* data, size_t size)`](../headers/Sorter.h).<br>

#### Все пункты выполнены

### Часть 2

# Анализ алгоритмов сортировки: Selection Sort и Heap Sort

## Таблица времени сортировки случайного массива

### Сравнительная таблица производительности на случайных данных (0.random)

| Алгоритм | 10² | 10³ | 10⁴ | 10⁵ | 10⁶ | 10⁷ |
|----------|-----|-----|-----|-----|-----|-----|
| **selection** | 0 мс | 1 мс | 121 мс | 12.70 сек | - | - |
| **heap_sort** | 0 мс | 0 мс | 2 мс | 36 мс | 461 мс | 6.99 сек |


**Примечания:**
- "-" означает, что тест был пропущен из-за временных ограничений (>2 минут)
- Все алгоритмы на 10², 10³ элементах показывают время <1 мс
- Heap sort показывает сравнимую с Shell сортировками производительность


## Часть 3: Комплексный анализ алгоритмов

**Шаблонный класс для тестов**: [`class Test`](../headers/Test.h), консольный вывод результатов тестирования [`output_part2.txt`](output_part2.txt)<br>
Для прогона всех алгоритмов через приложенный комплекс тестов сформированы параметры запуска тестов - [`test_cases.cpp`](../src/test_cases.cpp).<br>
**Примечание:** класс тестирования взят из прошлого домашнего задания, параметры запуска тестов отредактированы - алгоримты heap_sort добавлены, алгоритмы из прошлого ДЗ закомментированы_

Запись чисел отсортированного массива в файл результата:<br>
Функция запуска тестов шаблонного класса тестирования принимает опциональный параметр, определяющий, следует ли записывать отсортированный массив в файл. Для экономии времени и места полная программа тестирования проводилась без записи отсортированного массива в файлы (проверка данных в памяти). 
Отдельно были запущены тесты пирамидальной сортировки с записью в файлы, один из результирующих файлов представлен как образец [`test.6.sorted`](test.6.sorted)
В консольном выводе [`output_part2_.txt`](output_part2.txt) этот блок вывода находится после вывода комплексного тестирования.


### Сводная таблица производительности (100K элементов)

| Алгоритм | Random | Digits | Sorted | Revers | Адаптивность | Категория |
|----------|--------|--------|--------|--------|--------------|-----------|
| **selection** | 12.70 сек | 13.24 сек | 12.38 сек | 12.34 сек | Нулевая | Квадратичный |
| **heap_sort** | 36 мс | 28 мс | 29 мс | 27 мс | Низкая | N log N |

### Сводная таблица производительности (1M элементов)

| Алгоритм | Random | Digits | Sorted | Revers | Тестировался |
|----------|--------|--------|--------|--------|--------------|
| **heap_sort** | 461 мс | 313 мс | 345 мс | 323 мс | Да |
| **selection** | - | - | - | - | Нет (оценка: ~21 мин) |

### Сводная таблица производительности (10M элементов)

| Алгоритм | Random | Digits | Sorted | Revers |
|----------|--------|--------|--------|--------|
| **heap_sort** | 6.99 сек | 3.66 сек | 3.96 сек | 3.73 сек |
| **selection** | - | - | - | - | Нет |

## Детальный анализ Heap Sort

### Преимущества Heap Sort:
1. **Гарантированная сложность O(n log n)** во всех случаях (лучший, средний, худший)
2. **Не требует дополнительной памяти** (in-place сортировка)
3. **Стабильная производительность** на всех типах данных
4. **Нет риска деградации** до O(n²) в худшем случае

### Производительность по типам данных:
- **Digits (uint8_t)**: 3.66 сек на 10M - **самый быстрый**
- **Random**: 6.99 сек на 10M - стандартная производительность  
- **Revers**: 3.73 сек на 10M - немного быстрее random
- **Sorted**: 3.96 сек на 10M - сравнима с revers

### Сравнение с Shell Sort из прошлого ДЗ (sedgewick):
- **На 10M random**: heap_sort (6.99 сек) vs shell_sedgewick (3.81 сек) - **Shell в 1.8 раза быстрее**
- **На 10M digits**: heap_sort (3.66 сек) vs shell_sedgewick (1.20 сек) - **Shell в 3 раза быстрее**
- **На 1M random**: heap_sort (461 мс) vs shell_sedgewick (324 мс) - **Shell на 30% быстрее**

## Детальный анализ Selection Sort

### Характеристики Selection Sort:
1. **Сложность O(n²)** во всех случаях
2. **Абсолютно не адаптивный** - одинаковое время на sorted, random, revers
3. **Минимальное количество обменов** (n-1 обменов)
4. **Нестабильная** сортировка

### Ключевые наблюдения:
- **Время линейно растет**: 10⁴ (121 мс) → 10⁵ (12.7 сек) = **105-кратное увеличение**
- **Оценка для 1M**: ~21 минута (экстраполяция: 12.7 сек × 100 = 1270 сек ≈ 21 мин)
- **На digits работает даже медленнее**, чем на random (возможно, из-за особенностей кэша)

## Сравнительный анализ алгоритмов

### По сложности:
| Алгоритм | Лучший | Средний | Худший | Память |
|----------|--------|---------|--------|--------|
| **selection** | O(n²) | O(n²) | O(n²) | O(1) |
| **heap_sort** | O(n log n) | O(n log n) | O(n log n) | O(1) |
| *shell_sedgewick* | O(n log n) | O(n log² n) | O(n log² n) | O(1) |

### По адаптивности (реакция на sorted данные):
1. **insertion_bin**: 9.52 сек → 0.26 сек (**в 37 раз быстрее**)
2. **bubble**: 50.61 сек → 14.95 сек (**в 3.4 раза быстрее**)
3. **heap_sort**: 36 мс → 29 мс (незначительно)
4. **selection**: 12.70 сек → 12.38 сек (**практически не меняется**)

### По масштабируемости (от 10⁵ к 10⁶):
- **heap_sort**: 36 мс → 461 мс (**13-кратное увеличение**, ожидаемо для O(n log n))
- **selection**: 12.70 сек → ~21 мин (**100-кратное увеличение**, ожидаемо для O(n²))
- **shell_sedgewick**: 27 мс → 324 мс (**12-кратное увеличение**)

## Практические рекомендации

### Когда использовать Heap Sort:
1. **Требуется гарантированное O(n log n)** время в худшем случае
2. **Ограниченная память** - in-place алгоритм
3. **Реализация приоритетных очередей** как побочный продукт

### Когда использовать Selection Sort:
1. **Очень маленькие массивы** (<100 элементов)
2. **Минимизация обменов** критична (например, обмены дорогие)

### Сравнение с другими алгоритмами:
- **Против Insertion Sort**: heap_sort лучше на больших данных, хуже на почти отсортированных
- **Против Shell Sort**: heap_sort стабильнее по теории, но на практике Shell быстрее

## Ключевые выводы

### 1. Теоретические ожидания подтверждены:
- **Heap sort** действительно работает за O(n log n) на практике
- **Selection sort** подтверждает O(n²) сложность
- Разница в производительности между O(n²) и O(n log n) становится драматической на больших данных

### 2. Неожиданные результаты:
- **Shell sort (sedgewick)** оказался быстрее heap_sort на 30-80%
- **Heap sort** показывает удивительно стабильные результаты на всех типах данных
- **На digits данных** все алгоритмы работают существенно быстрее


## Заключение

Heap sort подтвердил свою репутацию надежного O(n log n) алгоритма с in-place выполнением, но на практике уступил оптимизированным Shell сортировкам. Selection sort, как и ожидалось, непригоден для сортировки больших массивов (>10⁵ элементов) из-за квадратичной сложности.

**Для общего использования рекомендуется shell_sedgewick**, который показал лучший баланс производительности и простоты реализации. **Heap sort** остается отличным выбором, когда критичны гарантии времени выполнения или ограничения по памяти.
